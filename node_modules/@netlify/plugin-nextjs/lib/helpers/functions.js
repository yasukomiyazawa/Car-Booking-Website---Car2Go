"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.warnOnApiRoutes = exports.packSingleFunction = exports.getExtendedApiRouteConfigs = exports.getApiRouteConfigs = exports.getAPILambdas = exports.getSSRLambdas = exports.getCommonDependencies = exports.traceNPMPackage = exports.setupImageFunction = exports.generatePagesResolver = exports.generateFunctions = void 0;
const node_bridge_1 = __importDefault(require("@vercel/node-bridge"));
const chalk_1 = __importDefault(require("chalk"));
const destr_1 = __importDefault(require("destr"));
const fs_extra_1 = require("fs-extra");
const outdent_1 = require("outdent");
const pathe_1 = require("pathe");
const tiny_glob_1 = __importDefault(require("tiny-glob"));
const constants_1 = require("../constants");
const getApiHandler_1 = require("../templates/getApiHandler");
const getHandler_1 = require("../templates/getHandler");
const getPageResolver_1 = require("../templates/getPageResolver");
const analysis_1 = require("./analysis");
const config_1 = require("./config");
const files_1 = require("./files");
const functionsMetaData_1 = require("./functionsMetaData");
const pack_1 = require("./pack");
const utils_1 = require("./utils");
const generateFunctions = async ({ INTERNAL_FUNCTIONS_SRC, PUBLISH_DIR, PACKAGE_PATH = '', FUNCTIONS_SRC = (0, pathe_1.join)(PACKAGE_PATH, constants_1.DEFAULT_FUNCTIONS_SRC), }, appDir, apiLambdas, ssrLambdas) => {
    const publish = (0, pathe_1.resolve)(PUBLISH_DIR);
    const functionsDir = (0, pathe_1.resolve)(INTERNAL_FUNCTIONS_SRC || FUNCTIONS_SRC);
    const functionDir = (0, pathe_1.join)(functionsDir, constants_1.HANDLER_FUNCTION_NAME);
    const publishDir = (0, pathe_1.relative)(functionDir, publish);
    const nextServerModuleAbsoluteLocation = (0, files_1.getServerFile)(appDir, false);
    const nextServerModuleRelativeLocation = nextServerModuleAbsoluteLocation
        ? (0, pathe_1.relative)(functionDir, nextServerModuleAbsoluteLocation)
        : undefined;
    for (const apiLambda of apiLambdas) {
        const { functionName, functionTitle, routes, type, includedFiles } = apiLambda;
        const apiHandlerSource = (0, getApiHandler_1.getApiHandler)({
            // most api lambdas serve multiple routes, but scheduled functions need to be in separate lambdas.
            // so routes[0] is safe to access.
            schedule: type === "experimental-scheduled" /* ApiRouteType.SCHEDULED */ ? routes[0].config.schedule : undefined,
            publishDir,
            appDir: (0, pathe_1.relative)(functionDir, appDir),
            nextServerModuleRelativeLocation,
        });
        await (0, fs_extra_1.ensureDir)((0, pathe_1.join)(functionsDir, functionName));
        // write main API handler file
        await (0, fs_extra_1.writeFile)((0, pathe_1.join)(functionsDir, functionName, `${functionName}.js`), apiHandlerSource);
        // copy handler dependencies (VercelNodeBridge, NetlifyNextServer, etc.)
        await (0, fs_extra_1.copyFile)(node_bridge_1.default, (0, pathe_1.join)(functionsDir, functionName, 'bridge.js'));
        await (0, fs_extra_1.copyFile)((0, pathe_1.join)(__dirname, '..', '..', 'lib', 'templates', 'server.js'), (0, pathe_1.join)(functionsDir, functionName, 'server.js'));
        await (0, fs_extra_1.copyFile)((0, pathe_1.join)(__dirname, '..', '..', 'lib', 'templates', 'requireHooks.js'), (0, pathe_1.join)(functionsDir, functionName, 'requireHooks.js'));
        await (0, fs_extra_1.copyFile)((0, pathe_1.join)(__dirname, '..', '..', 'lib', 'templates', 'handlerUtils.js'), (0, pathe_1.join)(functionsDir, functionName, 'handlerUtils.js'));
        const resolveSourceFile = (file) => (0, pathe_1.join)(publish, 'server', file);
        // TODO: this should be unneeded once we use the `none` bundler everywhere
        const resolverSource = await (0, getPageResolver_1.getResolverForSourceFiles)({
            functionsDir,
            // These extra pages are always included by Next.js
            sourceFiles: [
                ...routes.map((route) => route.compiled),
                'pages/_app.js',
                'pages/_document.js',
                'pages/_error.js',
            ].map(resolveSourceFile),
        });
        await (0, fs_extra_1.writeFile)((0, pathe_1.join)(functionsDir, functionName, 'pages.js'), resolverSource);
        await (0, functionsMetaData_1.writeFunctionConfiguration)({ functionName, functionTitle, functionsDir });
        const nfInternalFiles = await (0, tiny_glob_1.default)((0, pathe_1.join)(functionsDir, functionName, '**'));
        includedFiles.push(...nfInternalFiles);
    }
    const writeHandler = async (functionName, functionTitle, isODB) => {
        const handlerSource = (0, getHandler_1.getHandler)({
            isODB,
            publishDir,
            appDir: (0, pathe_1.relative)(functionDir, appDir),
            nextServerModuleRelativeLocation,
        });
        await (0, fs_extra_1.ensureDir)((0, pathe_1.join)(functionsDir, functionName));
        // write main handler file (standard or ODB)
        await (0, fs_extra_1.writeFile)((0, pathe_1.join)(functionsDir, functionName, `${functionName}.js`), handlerSource);
        // copy handler dependencies (VercelNodeBridge, NetlifyNextServer, etc.)
        await (0, fs_extra_1.copyFile)(node_bridge_1.default, (0, pathe_1.join)(functionsDir, functionName, 'bridge.js'));
        await (0, fs_extra_1.copyFile)((0, pathe_1.join)(__dirname, '..', '..', 'lib', 'templates', 'server.js'), (0, pathe_1.join)(functionsDir, functionName, 'server.js'));
        await (0, fs_extra_1.copyFile)((0, pathe_1.join)(__dirname, '..', '..', 'lib', 'templates', 'requireHooks.js'), (0, pathe_1.join)(functionsDir, functionName, 'requireHooks.js'));
        await (0, fs_extra_1.copyFile)((0, pathe_1.join)(__dirname, '..', '..', 'lib', 'templates', 'handlerUtils.js'), (0, pathe_1.join)(functionsDir, functionName, 'handlerUtils.js'));
        await (0, functionsMetaData_1.writeFunctionConfiguration)({ functionName, functionTitle, functionsDir });
        const nfInternalFiles = await (0, tiny_glob_1.default)((0, pathe_1.join)(functionsDir, functionName, '**'));
        const lambda = ssrLambdas.find((l) => l.functionName === functionName);
        if (lambda) {
            lambda.includedFiles.push(...nfInternalFiles);
        }
    };
    await writeHandler(constants_1.HANDLER_FUNCTION_NAME, constants_1.HANDLER_FUNCTION_TITLE, false);
    await writeHandler(constants_1.ODB_FUNCTION_NAME, constants_1.ODB_FUNCTION_TITLE, true);
};
exports.generateFunctions = generateFunctions;
/**
 * Writes a file in each function directory that contains references to every page entrypoint.
 * This is just so that the nft bundler knows about them. We'll eventually do this better.
 */
const generatePagesResolver = async ({ INTERNAL_FUNCTIONS_SRC, PUBLISH_DIR, PACKAGE_PATH = '', FUNCTIONS_SRC = (0, pathe_1.join)(PACKAGE_PATH, constants_1.DEFAULT_FUNCTIONS_SRC), }) => {
    const functionsPath = INTERNAL_FUNCTIONS_SRC || FUNCTIONS_SRC;
    const jsSource = await (0, getPageResolver_1.getResolverForPages)(PUBLISH_DIR, PACKAGE_PATH);
    await (0, fs_extra_1.writeFile)((0, pathe_1.join)(functionsPath, constants_1.ODB_FUNCTION_NAME, 'pages.js'), jsSource);
    await (0, fs_extra_1.writeFile)((0, pathe_1.join)(functionsPath, constants_1.HANDLER_FUNCTION_NAME, 'pages.js'), jsSource);
};
exports.generatePagesResolver = generatePagesResolver;
// Move our next/image function into the correct functions directory
const setupImageFunction = async ({ constants: { IS_LOCAL, INTERNAL_FUNCTIONS_SRC, PACKAGE_PATH = '', FUNCTIONS_SRC = (0, pathe_1.join)(PACKAGE_PATH, constants_1.DEFAULT_FUNCTIONS_SRC), }, imageconfig = {}, netlifyConfig, basePath, remotePatterns, responseHeaders, }) => {
    const imagePath = imageconfig.path || '/_next/image';
    if ((0, destr_1.default)(process.env.DISABLE_IPX)) {
        // If no image loader is specified, need to redirect to a 404 page since there's no
        // backing loader to serve local site images once deployed to Netlify
        if (!IS_LOCAL && imageconfig.loader === 'default') {
            netlifyConfig.redirects.push({
                from: `${imagePath}*`,
                query: { url: ':url', w: ':width', q: ':quality' },
                to: '/404.html',
                status: 404,
                force: true,
            });
        }
    }
    else {
        const functionsPath = INTERNAL_FUNCTIONS_SRC || FUNCTIONS_SRC;
        const functionName = `${constants_1.IMAGE_FUNCTION_NAME}.js`;
        const functionDirectory = (0, pathe_1.join)(functionsPath, constants_1.IMAGE_FUNCTION_NAME);
        await (0, fs_extra_1.ensureDir)(functionDirectory);
        await (0, fs_extra_1.writeJSON)((0, pathe_1.join)(functionDirectory, 'imageconfig.json'), {
            ...imageconfig,
            basePath: [basePath, constants_1.IMAGE_FUNCTION_NAME].join('/'),
            remotePatterns,
            responseHeaders,
        });
        await (0, fs_extra_1.copyFile)((0, pathe_1.join)(__dirname, '..', '..', 'lib', 'templates', 'ipx.js'), (0, pathe_1.join)(functionDirectory, functionName));
        (0, functionsMetaData_1.writeFunctionConfiguration)({
            functionName: constants_1.IMAGE_FUNCTION_NAME,
            functionTitle: constants_1.IMAGE_FUNCTION_TITLE,
            functionsDir: functionsPath,
        });
        // If we have edge functions then the request will have already been rewritten
        // so this won't match. This is matched if edge is disabled or unavailable.
        netlifyConfig.redirects.push({
            from: `${imagePath}*`,
            query: { url: ':url', w: ':width', q: ':quality' },
            to: `${basePath}/${constants_1.IMAGE_FUNCTION_NAME}/w_:width,q_:quality/:url`,
            status: 301,
        });
        netlifyConfig.redirects.push({
            from: `${basePath}/${constants_1.IMAGE_FUNCTION_NAME}/*`,
            to: `/.netlify/builders/${constants_1.IMAGE_FUNCTION_NAME}`,
            status: 200,
        });
    }
    if (basePath) {
        // next/image generates image static URLs that still point at the site root
        netlifyConfig.redirects.push({
            from: '/_next/static/image/*',
            to: '/static/image/:splat',
            status: 200,
        });
    }
};
exports.setupImageFunction = setupImageFunction;
const traceRequiredServerFiles = async (publish) => {
    var _a, _b, _c;
    const requiredServerFiles = await (0, config_1.getRequiredServerFiles)(publish);
    let appDirRoot = (_a = requiredServerFiles.appDir) !== null && _a !== void 0 ? _a : (0, pathe_1.join)(publish, '..');
    if (requiredServerFiles.relativeAppDir && ((_b = requiredServerFiles.config) === null || _b === void 0 ? void 0 : _b.experimental.outputFileTracingRoot)) {
        appDirRoot = (0, pathe_1.join)(requiredServerFiles.config.experimental.outputFileTracingRoot, requiredServerFiles.relativeAppDir);
    }
    const files = (_c = requiredServerFiles.files) !== null && _c !== void 0 ? _c : [];
    const absoluteFiles = files.map((file) => (0, pathe_1.join)(appDirRoot, file));
    absoluteFiles.push((0, pathe_1.join)(publish, 'required-server-files.json'));
    return absoluteFiles;
};
const traceNextServer = async (publish) => {
    const nextServerDeps = await (0, files_1.getDependenciesOfFile)((0, pathe_1.join)(publish, 'next-server.js'));
    // during testing, i've seen `next-server` contain only one line.
    // this is a sanity check to make sure we're getting all the deps.
    if (nextServerDeps.length < 10) {
        console.error(nextServerDeps);
        throw new Error("next-server.js.nft.json didn't contain all dependencies.");
    }
    const filtered = nextServerDeps.filter((f) => {
        // NFT detects a bunch of large development files that we don't need.
        if (f.endsWith('.development.js'))
            return false;
        // not needed for API Routes!
        if (f.endsWith('node_modules/sass/sass.dart.js'))
            return false;
        return true;
    });
    return filtered;
};
const traceNPMPackage = async (packageName, publish) => {
    try {
        return await (0, tiny_glob_1.default)((0, pathe_1.join)((0, pathe_1.dirname)(require.resolve(packageName, { paths: [__dirname, publish] })), '**', '*'), {
            absolute: true,
        });
    }
    catch (error) {
        if (process.env.NODE_ENV === 'test') {
            return [];
        }
        throw error;
    }
};
exports.traceNPMPackage = traceNPMPackage;
const getCommonDependencies = async (publish) => {
    const deps = await Promise.all([
        traceRequiredServerFiles(publish),
        traceNextServer(publish),
        // used by our own bridge.js
        (0, exports.traceNPMPackage)('follow-redirects', publish),
        // using package.json because otherwise, we'd find some /dist/... path
        (0, exports.traceNPMPackage)('@netlify/functions/package.json', publish),
        (0, exports.traceNPMPackage)('is-promise', publish),
    ]);
    return deps.flat(1);
};
exports.getCommonDependencies = getCommonDependencies;
const sum = (arr) => arr.reduce((v, current) => v + current, 0);
// TODO: cache results
const getBundleWeight = async (patterns) => {
    const sizes = await Promise.all(patterns.flatMap(async (pattern) => {
        const files = await (0, tiny_glob_1.default)(pattern);
        return Promise.all(files.map(async (file) => {
            const fStat = await (0, fs_extra_1.stat)(file);
            if (fStat.isFile()) {
                return fStat.size;
            }
            return 0;
        }));
    }));
    return sum(sizes.flat(1));
};
const changeExtension = (file, extension) => {
    const base = (0, pathe_1.basename)(file, (0, pathe_1.extname)(file));
    return (0, pathe_1.join)((0, pathe_1.dirname)(file), base + extension);
};
const getSSRDependencies = async (publish) => {
    const prerenderManifest = await (0, fs_extra_1.readJSON)((0, pathe_1.join)(publish, 'prerender-manifest.json'));
    return [
        ...Object.entries(prerenderManifest.routes).flatMap(([route, ssgRoute]) => {
            if (ssgRoute.initialRevalidateSeconds === false) {
                return [];
            }
            if (ssgRoute.dataRoute.endsWith('.rsc')) {
                return [
                    (0, pathe_1.join)(publish, 'server', 'app', ssgRoute.dataRoute),
                    (0, pathe_1.join)(publish, 'server', 'app', changeExtension(ssgRoute.dataRoute, '.html')),
                ];
            }
            const trimmedPath = route === '/' ? 'index' : route.slice(1);
            return [
                (0, pathe_1.join)(publish, 'server', 'pages', `${trimmedPath}.html`),
                (0, pathe_1.join)(publish, 'server', 'pages', `${trimmedPath}.json`),
            ];
        }),
        (0, pathe_1.join)(publish, '**', '*.html'),
        (0, pathe_1.join)(publish, 'static-manifest.json'),
    ];
};
const getSSRLambdas = async (publish) => {
    const commonDependencies = await (0, exports.getCommonDependencies)(publish);
    const ssrRoutes = await getSSRRoutes(publish);
    // TODO: for now, they're the same - but we should separate them
    const nonOdbRoutes = ssrRoutes;
    const odbRoutes = ssrRoutes;
    const ssrDependencies = await getSSRDependencies(publish);
    return [
        {
            functionName: constants_1.HANDLER_FUNCTION_NAME,
            functionTitle: constants_1.HANDLER_FUNCTION_TITLE,
            includedFiles: [
                ...commonDependencies,
                ...ssrDependencies,
                ...nonOdbRoutes.flatMap((route) => route.includedFiles),
            ],
            routes: nonOdbRoutes,
        },
        {
            functionName: constants_1.ODB_FUNCTION_NAME,
            functionTitle: constants_1.ODB_FUNCTION_TITLE,
            includedFiles: [...commonDependencies, ...ssrDependencies, ...odbRoutes.flatMap((route) => route.includedFiles)],
            routes: odbRoutes,
        },
    ];
};
exports.getSSRLambdas = getSSRLambdas;
const getSSRRoutes = async (publish) => {
    const pageManifest = (await (0, fs_extra_1.readJSON)((0, pathe_1.join)(publish, 'server', 'pages-manifest.json')));
    const pageManifestRoutes = Object.entries(pageManifest).filter(([page, compiled]) => !page.startsWith('/api/') && !compiled.endsWith('.html'));
    const appPathsManifest = await (0, fs_extra_1.readJSON)((0, pathe_1.join)(publish, 'server', 'app-paths-manifest.json')).catch(() => ({}));
    const appRoutes = Object.entries(appPathsManifest);
    const routes = [...pageManifestRoutes, ...appRoutes];
    return await Promise.all(routes.map(async ([route, compiled]) => {
        const functionName = (0, utils_1.getFunctionNameForPage)(route);
        const compiledPath = (0, pathe_1.join)(publish, 'server', compiled);
        const routeDependencies = await (0, files_1.getDependenciesOfFile)(compiledPath);
        const includedFiles = [compiledPath, ...routeDependencies];
        return {
            functionName,
            route,
            compiled,
            includedFiles,
        };
    }));
};
const getAPILambdas = async (publish, baseDir, pageExtensions) => {
    const commonDependencies = await (0, exports.getCommonDependencies)(publish);
    const threshold = constants_1.LAMBDA_WARNING_SIZE - (await getBundleWeight(commonDependencies));
    const apiRoutes = await (0, exports.getApiRouteConfigs)(publish, baseDir, pageExtensions);
    const packFunctions = async (routes, type) => {
        const weighedRoutes = await Promise.all(routes.map(async (route) => ({ value: route, weight: await getBundleWeight(route.includedFiles) })));
        const bins = (0, pack_1.pack)(weighedRoutes, threshold);
        return bins.map((bin) => {
            if (bin.length === 1) {
                const [func] = bin;
                const { functionName, functionTitle, config, includedFiles } = func;
                return {
                    functionName,
                    functionTitle,
                    routes: [func],
                    includedFiles: [...commonDependencies, ...includedFiles],
                    type: config.type,
                };
            }
            const includedFiles = [...commonDependencies, ...bin.flatMap((route) => route.includedFiles)];
            const nonSingletonBins = bins.filter((b) => b.length > 1);
            if (nonSingletonBins.length === 1) {
                return {
                    functionName: constants_1.API_FUNCTION_NAME,
                    functionTitle: constants_1.API_FUNCTION_TITLE,
                    includedFiles,
                    routes: bin,
                    type,
                };
            }
            const indexInNonSingletonBins = nonSingletonBins.indexOf(bin);
            return {
                functionName: `${constants_1.API_FUNCTION_NAME}-${indexInNonSingletonBins + 1}`,
                functionTitle: `${constants_1.API_FUNCTION_TITLE} ${indexInNonSingletonBins + 1}/${nonSingletonBins.length}`,
                includedFiles,
                routes: bin,
                type,
            };
        });
    };
    const standardFunctions = apiRoutes.filter((route) => !(0, analysis_1.isEdgeConfig)(route.config.runtime) &&
        route.config.type !== "experimental-background" /* ApiRouteType.BACKGROUND */ &&
        route.config.type !== "experimental-scheduled" /* ApiRouteType.SCHEDULED */);
    const scheduledFunctions = apiRoutes.filter((route) => route.config.type === "experimental-scheduled" /* ApiRouteType.SCHEDULED */);
    const backgroundFunctions = apiRoutes.filter((route) => route.config.type === "experimental-background" /* ApiRouteType.BACKGROUND */);
    const scheduledLambdas = scheduledFunctions.map(exports.packSingleFunction);
    const [standardLambdas, backgroundLambdas] = await Promise.all([
        packFunctions(standardFunctions),
        packFunctions(backgroundFunctions, "experimental-background" /* ApiRouteType.BACKGROUND */),
    ]);
    return [...standardLambdas, ...backgroundLambdas, ...scheduledLambdas];
};
exports.getAPILambdas = getAPILambdas;
/**
 * Look for API routes, and extract the config from the source file.
 */
const getApiRouteConfigs = async (publish, appDir, pageExtensions) => {
    const pages = await (0, fs_extra_1.readJSON)((0, pathe_1.join)(publish, 'server', 'pages-manifest.json'));
    const apiRoutes = Object.keys(pages).filter((page) => page.startsWith('/api/'));
    // two possible places
    // Ref: https://nextjs.org/docs/advanced-features/src-directory
    const pagesDir = (0, pathe_1.join)(appDir, 'pages');
    const srcPagesDir = (0, pathe_1.join)(appDir, 'src', 'pages');
    return await Promise.all(apiRoutes.map(async (apiRoute) => {
        const filePath = (0, files_1.getSourceFileForPage)(apiRoute, [pagesDir, srcPagesDir], pageExtensions);
        const config = await (0, analysis_1.extractConfigFromFile)(filePath, appDir);
        const functionName = (0, utils_1.getFunctionNameForPage)(apiRoute, config.type === "experimental-background" /* ApiRouteType.BACKGROUND */);
        const functionTitle = `${constants_1.API_FUNCTION_TITLE} ${apiRoute}`;
        const compiled = pages[apiRoute];
        const compiledPath = (0, pathe_1.join)(publish, 'server', compiled);
        const routeDependencies = await (0, files_1.getDependenciesOfFile)(compiledPath);
        const includedFiles = [compiledPath, ...routeDependencies];
        return {
            functionName,
            functionTitle,
            route: apiRoute,
            config,
            compiled,
            includedFiles,
        };
    }));
};
exports.getApiRouteConfigs = getApiRouteConfigs;
/**
 * Looks for extended API routes (background and scheduled functions) and extract the config from the source file.
 */
const getExtendedApiRouteConfigs = async (publish, appDir, pageExtensions) => {
    const settledApiRoutes = await (0, exports.getApiRouteConfigs)(publish, appDir, pageExtensions);
    // We only want to return the API routes that are background or scheduled functions
    return settledApiRoutes.filter((apiRoute) => apiRoute.config.type !== undefined);
};
exports.getExtendedApiRouteConfigs = getExtendedApiRouteConfigs;
const packSingleFunction = (func) => ({
    functionName: func.functionName,
    functionTitle: func.functionTitle,
    includedFiles: func.includedFiles,
    routes: [func],
    type: func.config.type,
});
exports.packSingleFunction = packSingleFunction;
/**
 * Warn the user of the caveats if they're using background or scheduled API routes
 */
const warnOnApiRoutes = async ({ FUNCTIONS_DIST, }) => {
    const functionsManifestPath = (0, pathe_1.join)(FUNCTIONS_DIST, 'manifest.json');
    if (!(0, fs_extra_1.existsSync)(functionsManifestPath)) {
        return;
    }
    const { functions } = await (0, fs_extra_1.readJSON)(functionsManifestPath);
    if (functions.some((func) => func.name.endsWith('-background'))) {
        console.warn((0, outdent_1.outdent) `
        ${chalk_1.default.yellowBright `Using background API routes`}
        If your account type does not support background functions, the deploy will fail.
        During local development, background API routes will run as regular API routes, but in production they will immediately return an empty "202 Accepted" response.
      `);
    }
    if (functions.some((func) => func.schedule)) {
        console.warn((0, outdent_1.outdent) `
        ${chalk_1.default.yellowBright `Using scheduled API routes`}
        These are run on a schedule when deployed to production.
        You can test them locally by loading them in your browser but this will not be available when deployed, and any returned value is ignored.
      `);
    }
};
exports.warnOnApiRoutes = warnOnApiRoutes;
