"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeFunctionConfiguration = exports.getPluginVersion = void 0;
const fs_extra_1 = require("fs-extra");
const pathe_1 = require("pathe");
const constants_1 = require("../constants");
const config_1 = require("./config");
const getNextRuntimeVersion = async (packageJsonPath, useNodeModulesPath) => {
    if (!(0, fs_extra_1.existsSync)(packageJsonPath)) {
        return;
    }
    const packagePlugin = await (0, fs_extra_1.readJSON)(packageJsonPath);
    return useNodeModulesPath ? packagePlugin.version : packagePlugin.dependencies[constants_1.NEXT_PLUGIN];
};
const PLUGIN_PACKAGE_PATH = '.netlify/plugins/package.json';
const nextPluginVersion = async () => {
    const moduleRoot = (0, config_1.resolveModuleRoot)(constants_1.NEXT_PLUGIN);
    const nodeModulesPath = moduleRoot ? (0, pathe_1.join)(moduleRoot, 'package.json') : null;
    return ((await getNextRuntimeVersion(nodeModulesPath, true)) ||
        (await getNextRuntimeVersion(PLUGIN_PACKAGE_PATH, false)) ||
        // The runtime version should always be available, but if it's not, return 'unknown'
        'unknown');
};
const getPluginVersion = async () => `${constants_1.NEXT_PLUGIN_NAME}@${await nextPluginVersion()}`;
exports.getPluginVersion = getPluginVersion;
/**
 * Creates a function configuration file for the given function.
 *
 * @param functionInfo The information needed to create a function configuration file
 */
const writeFunctionConfiguration = async (functionInfo) => {
    const { functionName, functionTitle, functionsDir } = functionInfo;
    const generator = await (0, exports.getPluginVersion)();
    const metadata = {
        config: {
            name: functionTitle,
            generator,
        },
        version: 1,
    };
    await (0, fs_extra_1.writeFile)((0, pathe_1.join)(functionsDir, functionName, `${functionName}.json`), JSON.stringify(metadata));
};
exports.writeFunctionConfiguration = writeFunctionConfiguration;
